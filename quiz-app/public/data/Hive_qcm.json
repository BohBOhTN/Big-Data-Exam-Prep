{
  "topic_name": "Apache Hive",
  "topic_description": "Questions avec Corrections et Conseils",
  "author": "Mohamed KOUBAA",
  "num_questions": 40,
  "questions": [
    {
      "question_number": 1,
      "question_text": "Hive a √©t√© initialement d√©velopp√© par quelle entreprise ?",
      "options": [
        {
          "letter": "A",
          "text": "Google",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Yahoo",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "Facebook",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "Amazon",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "Facebook a d√©velopp√© Hive pour analyser leurs donn√©es massives. Ensuite, il a √©t√© donn√© √† l'Apache Software Foundation comme projet open source."
    },
    {
      "question_number": 2,
      "question_text": "Qu'est-ce que Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "Une base de donn√©es relationnelle temps r√©el",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Un outil d'entrep√¥t de donn√©es (Data Warehouse) pour Hadoop",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Un syst√®me de fichiers distribu√©",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Un broker de messages",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Hive = Data Warehouse sur Hadoop. Il permet d'analyser de grands volumes de donn√©es avec un langage SQL-like, mais ce n'est PAS une base de donn√©es temps r√©el."
    },
    {
      "question_number": 3,
      "question_text": "Quel langage de requ√™te utilise Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "SQL standard",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Pig Latin",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "HiveQL (SQL-like)",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "Python",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "HiveQL ressemble √† SQL mais avec quelques diff√©rences. Il est compil√© en jobs MapReduce (ou Tez/Spark) pour l'ex√©cution sur Hadoop."
    },
    {
      "question_number": 4,
      "question_text": "Hive est-il adapt√© pour les requ√™tes temps r√©el ?",
      "options": [
        {
          "letter": "A",
          "text": "Oui, c'est son usage principal",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Non, il n'est pas con√ßu pour le temps r√©el",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Seulement avec des plugins",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Uniquement pour les petites requ√™tes",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Hive est pour l'analyse batch (ETL, reporting). Pour le temps r√©el, utilisez Impala, Presto, ou des bases temps r√©el comme HBase."
    },
    {
      "question_number": 5,
      "question_text": "Quel composant Hive stocke les m√©tadonn√©es des tables ?",
      "options": [
        {
          "letter": "A",
          "text": "Driver",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Metastore",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Compiler",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Execution Engine",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Le Metastore contient : sch√©mas des tables, emplacements HDFS, partitions, etc. Il utilise g√©n√©ralement une base relationnelle (MySQL, PostgreSQL)."
    },
    {
      "question_number": 6,
      "question_text": "Par d√©faut, o√π sont stock√©es les tables internes Hive dans HDFS ?",
      "options": [
        {
          "letter": "A",
          "text": "/data/hive/",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "/user/hive/warehouse/",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "/tmp/hive/",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "/hive/tables/",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Chemin par d√©faut : `/user/hive/warehouse/database_name.db/table_name/`. Les tables externes peuvent √™tre n'importe o√π via LOCATION."
    },
    {
      "question_number": 7,
      "question_text": "Quelle est la diff√©rence principale entre une table INTERNE et une table EXTERNE ?",
      "options": [
        {
          "letter": "A",
          "text": "Aucune diff√©rence",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "La table externe garde les donn√©es lors du DROP, la table interne les supprime",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "La table interne est plus rapide",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "La table externe ne supporte pas les partitions",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "DROP TABLE INTERNE = supprime m√©tadonn√©es ET donn√©es. DROP TABLE EXTERNE = supprime m√©tadonn√©es SEULEMENT, les fichiers restent dans HDFS."
    },
    {
      "question_number": 8,
      "question_text": "Quel mot-cl√© permet de cr√©er une table externe ?",
      "options": [
        {
          "letter": "A",
          "text": "OUTER",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "EXTERNAL",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "OUTSIDE",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "REMOTE",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`CREATE EXTERNAL TABLE ... LOCATION '/path/'`. Le mot-cl√© EXTERNAL indique que Hive ne g√®re pas le cycle de vie des donn√©es."
    },
    {
      "question_number": 9,
      "question_text": "Quel est le format de stockage par d√©faut dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "PARQUET",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "ORC",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "TEXTFILE",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "AVRO",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "TEXTFILE = format par d√©faut (lisible, mais peu performant). En production, pr√©f√©rez ORC ou PARQUET pour de meilleures performances."
    },
    {
      "question_number": 10,
      "question_text": "Quel format de stockage est orient√© colonnes et offre une meilleure compression ?",
      "options": [
        {
          "letter": "A",
          "text": "TEXTFILE",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "PARQUET ou ORC",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "CSV",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "JSON",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "ORC et PARQUET = formats orient√©s colonnes. Avantages : compression efficace, lecture s√©lective de colonnes, meilleure performance pour l'analytique."
    },
    {
      "question_number": 11,
      "question_text": "Qu'est-ce qu'un SerDe dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "Un type de donn√©es",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Un Serializer/Deserializer pour lire/√©crire les donn√©es",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Un format de compression",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Un type de table",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "SerDe = Serializer/Deserializer. Il d√©finit comment lire les lignes du fichier en colonnes et inversement. Ex: OpenCSVSerde, RegexSerde."
    },
    {
      "question_number": 12,
      "question_text": "Quelle commande permet de charger un fichier local dans une table Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "INSERT DATA LOCAL",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "LOAD DATA LOCAL INPATH",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "COPY DATA FROM",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "IMPORT DATA LOCAL",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`LOAD DATA LOCAL INPATH '/local/path' INTO TABLE table_name`. LOCAL = fichier local, sans LOCAL = fichier HDFS."
    },
    {
      "question_number": 13,
      "question_text": "Que fait le mot-cl√© OVERWRITE dans la commande LOAD DATA ?",
      "options": [
        {
          "letter": "A",
          "text": "Ajoute les donn√©es √† la suite",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Remplace le contenu existant de la table",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Cr√©e une nouvelle table",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Supprime la table",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`LOAD DATA ... OVERWRITE INTO TABLE` supprime les donn√©es existantes avant de charger. Sans OVERWRITE, les donn√©es sont ajout√©es."
    },
    {
      "question_number": 14,
      "question_text": "Qu'est-ce que le partitionnement dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "La compression des donn√©es",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "La division des donn√©es en r√©pertoires bas√©s sur les valeurs d'une colonne",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Le tri des donn√©es",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "La suppression des doublons",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Partitionnement = 1 r√©pertoire par valeur. Ex: PARTITIONED BY (year INT) cr√©e /year=2023/, /year=2024/. Acc√©l√®re les requ√™tes avec filtres."
    },
    {
      "question_number": 15,
      "question_text": "Dans le partitionnement, que cr√©e Hive pour chaque valeur de partition ?",
      "options": [
        {
          "letter": "A",
          "text": "Un fichier",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Un r√©pertoire",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Une table",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Une base de donn√©es",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Partition = r√©pertoire dans HDFS. Structure : `.../table/partition_col=value/data_files`. Hive ne lit que les r√©pertoires pertinents."
    },
    {
      "question_number": 16,
      "question_text": "Qu'est-ce que le Bucketing dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "La cr√©ation de sauvegardes",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "La division des donn√©es en fichiers bas√©e sur le hash d'une colonne",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Le tri alphab√©tique",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "La compression des donn√©es",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Bucketing = hash(colonne) % n_buckets d√©termine le fichier. Utile pour : jointures optimis√©es, sampling. Compl√©mentaire au partitionnement."
    },
    {
      "question_number": 17,
      "question_text": "Dans le Bucketing, que cr√©e Hive pour chaque bucket ?",
      "options": [
        {
          "letter": "A",
          "text": "Un r√©pertoire",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Un fichier",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Une partition",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Une table",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Bucket = fichier. `INTO 8 BUCKETS` cr√©e 8 fichiers (000000_0, 000001_0, ...). Diff√©rent du partitionnement qui cr√©e des r√©pertoires."
    },
    {
      "question_number": 18,
      "question_text": "Quelle clause permet de d√©finir le nombre de buckets ?",
      "options": [
        {
          "letter": "A",
          "text": "PARTITIONED BY",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "CLUSTERED BY ... INTO n BUCKETS",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "GROUPED BY",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "DIVIDED INTO",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`CLUSTERED BY (col) INTO n BUCKETS`. Optionnel : `SORTED BY (col)` pour trier dans chaque bucket. Am√©liore les jointures et le sampling."
    },
    {
      "question_number": 19,
      "question_text": "Quel type de donn√©es Hive repr√©sente un entier sur 4 bytes ?",
      "options": [
        {
          "letter": "A",
          "text": "TINYINT",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "SMALLINT",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "INT",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "BIGINT",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "Types entiers : TINYINT (1 byte), SMALLINT (2 bytes), INT (4 bytes), BIGINT (8 bytes). Choisissez selon la plage de valeurs."
    },
    {
      "question_number": 20,
      "question_text": "Quel type de donn√©es Hive permet de stocker une cha√Æne jusqu'√† 2G ?",
      "options": [
        {
          "letter": "A",
          "text": "CHAR",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "VARCHAR",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "STRING",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "TEXT",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "STRING = longueur max 2 Go, pas de limite fixe. CHAR = fixe (255 max), VARCHAR = variable (65535 max). STRING est le plus flexible."
    },
    {
      "question_number": 21,
      "question_text": "Que fait la commande DESCRIBE FORMATTED table_name ?",
      "options": [
        {
          "letter": "A",
          "text": "Supprime la table",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Affiche les m√©tadonn√©es d√©taill√©es de la table",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Cr√©e une nouvelle table",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Modifie la structure de la table",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`DESCRIBE FORMATTED` montre : colonnes, types, partitions, emplacement HDFS, format, SerDe, propri√©t√©s. Plus complet que `DESCRIBE` simple."
    },
    {
      "question_number": 22,
      "question_text": "Qu'est-ce que CTAS dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "Create Table As Select",
          "is_correct": true
        },
        {
          "letter": "B",
          "text": "Copy Table And Save",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "Create Temporary Archive Storage",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Compile Table And Sort",
          "is_correct": false
        }
      ],
      "correct_answer": "A",
      "conseil": "CTAS = `CREATE TABLE new_table AS SELECT ...`. Cr√©e une table et la remplit en une seule commande. Utile pour les transformations ETL."
    },
    {
      "question_number": 23,
      "question_text": "La commande CTAS cr√©e quel type de table par d√©faut ?",
      "options": [
        {
          "letter": "A",
          "text": "Table externe",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Table interne",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Table temporaire",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Vue",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "CTAS cr√©e toujours une table interne (managed). Pour cr√©er une table externe, utilisez CREATE EXTERNAL TABLE puis INSERT."
    },
    {
      "question_number": 24,
      "question_text": "Que fait la commande CREATE TABLE new_table LIKE existing_table ?",
      "options": [
        {
          "letter": "A",
          "text": "Copie les donn√©es",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Clone la structure sans les donn√©es",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Cr√©e une vue",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Fusionne les tables",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "LIKE copie le sch√©ma (colonnes, types, partitions, format) mais pas les donn√©es. Utile pour cr√©er des tables avec la m√™me structure."
    },
    {
      "question_number": 25,
      "question_text": "Quelle propri√©t√© permet d'ignorer la premi√®re ligne (en-t√™tes) d'un fichier ?",
      "options": [
        {
          "letter": "A",
          "text": "skip.first.line",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "skip.header.line.count",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "ignore.header",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "header.skip",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`TBLPROPERTIES('skip.header.line.count'='1')`. Ignore les N premi√®res lignes (headers) lors du chargement. Essentiel pour les CSV avec en-t√™tes."
    },
    {
      "question_number": 26,
      "question_text": "Quelle est la syntaxe pour ins√©rer des valeurs directement dans une table ?",
      "options": [
        {
          "letter": "A",
          "text": "ADD VALUES",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "INSERT INTO TABLE ... VALUES",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "PUT VALUES",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "LOAD VALUES",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`INSERT INTO TABLE t VALUES (v1, v2, ...)`. Possible depuis Hive 0.14. Pour les insertions massives, pr√©f√©rez LOAD DATA ou INSERT...SELECT."
    },
    {
      "question_number": 27,
      "question_text": "Que signifie le partitionnement dynamique dans Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "Les partitions sont cr√©√©es automatiquement selon les donn√©es",
          "is_correct": true
        },
        {
          "letter": "B",
          "text": "Les partitions sont cr√©√©es manuellement",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "Les partitions sont supprim√©es automatiquement",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Les partitions sont compress√©es",
          "is_correct": false
        }
      ],
      "correct_answer": "A",
      "conseil": "Dynamique : Hive cr√©e les partitions selon les valeurs trouv√©es dans les donn√©es. Statique : vous sp√©cifiez la valeur de partition explicitement."
    },
    {
      "question_number": 28,
      "question_text": "Quelle variable doit √™tre configur√©e pour activer le partitionnement dynamique ?",
      "options": [
        {
          "letter": "A",
          "text": "hive.partition.mode",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "hive.exec.dynamic.partition.mode",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "hive.dynamic.partition",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "hive.auto.partition",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`SET hive.exec.dynamic.partition.mode=nonstrict`. Par d√©faut = strict (requiert au moins une partition statique). nonstrict = tout dynamique."
    },
    {
      "question_number": 29,
      "question_text": "Quelle fonction retourne la valeur par d√©faut si la premi√®re est NULL ?",
      "options": [
        {
          "letter": "A",
          "text": "ifnull()",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "nvl()",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "coalesce()",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "default()",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`nvl(value, default)` = retourne default si value est NULL. `coalesce(v1, v2, ...)` retourne la premi√®re valeur non-NULL parmi plusieurs."
    },
    {
      "question_number": 30,
      "question_text": "Quelle fonction permet de convertir un type de donn√©es en un autre ?",
      "options": [
        {
          "letter": "A",
          "text": "convert()",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "cast()",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "transform()",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "change()",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`CAST(expr AS type)`. Ex: `CAST('123' AS INT)`, `CAST(date_col AS STRING)`. Essentiel pour les conversions de types."
    },
    {
      "question_number": 31,
      "question_text": "Quelle clause permet de filtrer les r√©sultats d'agr√©gation ?",
      "options": [
        {
          "letter": "A",
          "text": "WHERE",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "HAVING",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "FILTER",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "LIMIT",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "WHERE filtre avant l'agr√©gation, HAVING filtre apr√®s. `GROUP BY col HAVING COUNT(*) > 10` filtre les groupes."
    },
    {
      "question_number": 32,
      "question_text": "Les fonctions d'agr√©gation peuvent-elles √™tre utilis√©es dans la clause WHERE ?",
      "options": [
        {
          "letter": "A",
          "text": "Oui, toujours",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Non, jamais",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Seulement avec GROUP BY",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Seulement avec DISTINCT",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "WHERE ne peut pas contenir d'agr√©gations car elle s'ex√©cute AVANT le GROUP BY. Utilisez HAVING pour filtrer sur des agr√©gats."
    },
    {
      "question_number": 33,
      "question_text": "Quelle jointure retourne toutes les lignes des deux tables ?",
      "options": [
        {
          "letter": "A",
          "text": "INNER JOIN",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "LEFT JOIN",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "FULL OUTER JOIN",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "RIGHT JOIN",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "FULL OUTER JOIN = toutes les lignes des deux tables, avec NULL pour les non-correspondances. LEFT/RIGHT = toutes d'un c√¥t√© seulement."
    },
    {
      "question_number": 34,
      "question_text": "Par d√©faut, que fait Hive avec les doublons lors d'un UNION ?",
      "options": [
        {
          "letter": "A",
          "text": "Les conserve tous",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Les √©limine",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "G√©n√®re une erreur",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Les compte",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`UNION` = `UNION DISTINCT` par d√©faut, √©limine les doublons. Pour tout garder, utilisez `UNION ALL`."
    },
    {
      "question_number": 35,
      "question_text": "Quelle option UNION conserve tous les doublons ?",
      "options": [
        {
          "letter": "A",
          "text": "UNION DISTINCT",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "UNION ALL",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "UNION KEEP",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "UNION FULL",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "UNION ALL = conserve TOUS les enregistrements, y compris les doublons. Plus performant car pas de d√©duplication."
    },
    {
      "question_number": 36,
      "question_text": "Quel format de fichier est recommand√© pour les sch√©mas √©volutifs ?",
      "options": [
        {
          "letter": "A",
          "text": "TEXTFILE",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "ORC",
          "is_correct": false
        },
        {
          "letter": "C",
          "text": "AVRO",
          "is_correct": true
        },
        {
          "letter": "D",
          "text": "PARQUET",
          "is_correct": false
        }
      ],
      "correct_answer": "C",
      "conseil": "AVRO = excellent pour l'√©volution de sch√©ma (ajout/suppression de colonnes). Le sch√©ma est stock√© avec les donn√©es. ORC/PARQUET sont plus performants mais moins flexibles."
    },
    {
      "question_number": 37,
      "question_text": "Quelle fonction permet de masquer les donn√©es sensibles ?",
      "options": [
        {
          "letter": "A",
          "text": "hide()",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "mask()",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "encrypt()",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "protect()",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`mask(string)` : majuscules‚ÜíX, minuscules‚Üíx, chiffres‚Üín. Ex: \"Allen\" ‚Üí \"Xxxxx\", \"123\" ‚Üí \"nnn\". Utile pour anonymiser."
    },
    {
      "question_number": 38,
      "question_text": "Quelle commande permet de supprimer une base de donn√©es avec toutes ses tables ?",
      "options": [
        {
          "letter": "A",
          "text": "DROP DATABASE name",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "DROP DATABASE name CASCADE",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "DELETE DATABASE name",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "REMOVE DATABASE name ALL",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "`DROP DATABASE name` √©choue si la BD contient des tables. `DROP DATABASE name CASCADE` supprime d'abord toutes les tables puis la BD."
    },
    {
      "question_number": 39,
      "question_text": "Quel moteur d'ex√©cution moderne peut remplacer MapReduce pour Hive ?",
      "options": [
        {
          "letter": "A",
          "text": "Storm",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Apache Tez ou Spark",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Kafka",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "Flume",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Tez (optimis√© pour les DAG) et Spark (in-memory) sont bien plus rapides que MapReduce pour Hive. Configuration : `SET hive.execution.engine=tez`."
    },
    {
      "question_number": 40,
      "question_text": "Quel avantage offre le Bucketing pour les jointures ?",
      "options": [
        {
          "letter": "A",
          "text": "Compression des donn√©es",
          "is_correct": false
        },
        {
          "letter": "B",
          "text": "Optimisation des JOIN entre tables avec m√™me bucketing",
          "is_correct": true
        },
        {
          "letter": "C",
          "text": "Acc√©l√©ration des INSERT",
          "is_correct": false
        },
        {
          "letter": "D",
          "text": "R√©duction de la taille des tables",
          "is_correct": false
        }
      ],
      "correct_answer": "B",
      "conseil": "Deux tables avec m√™me cl√© de bucket et m√™me nombre de buckets = jointure optimis√©e. Hive peut joindre bucket par bucket sans shuffle global. ## üìä R√©sum√© des Th√®mes Abord√©s | Th√®me | Nombre de Questions | |-------|---------------------| | Concepts Hive (architecture, m√©tastore) | 6 | | Types de tables (interne, externe) | 4 | | Formats de stockage et SerDe | 5 | | DDL (CREATE, DROP, ALTER) | 6 | | DML (LOAD, INSERT) | 4 | | Partitionnement et Bucketing | 6 | | DQL (SELECT, JOIN, fonctions) | 9 | ## Conseils pour l'Examen 1. Distinguez les types de tables : - INTERNE : Hive g√®re les donn√©es (supprim√©es au DROP) - EXTERNE : Donn√©es ind√©pendantes (conserv√©es au DROP) 2. Connaissez les formats de stockage : - TEXTFILE : d√©faut, lisible, peu performant - ORC/PARQUET : colonnes, compression, performant - AVRO : √©volution de sch√©ma 3. Comprenez Partitionnement vs Bucketing : - Partition = r√©pertoire (valeurs de colonne) - Bucket = fichier (hash de colonne) 4. Ma√Ætrisez les commandes cl√©s : - LOAD DATA [LOCAL] INPATH - INSERT INTO/OVERWRITE - CREATE TABLE ... AS SELECT (CTAS) - DESCRIBE FORMATTED 5. Retenez les fonctions importantes : - nvl(), cast(), mask() - Agr√©gations : count, sum, avg, min, max Bonne chance pour votre examen ! üçÄ"
    }
  ]
}